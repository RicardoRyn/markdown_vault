# 简介

程序将会生成一个 1 到 100 之间的随机整数。
然后提示玩家输入一个猜测值。
输入后，程序会指示该猜测是太低还是太高。
如果猜对了，游戏会打印祝贺信息并退出。

# 处理一次猜测

代码：

```rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}
```

为了获取用户输入并打印结果作为输出，我们需要将 io 输入/输出库引入当前作用域。
`io` 库来自于标准库，也被称为 `std`：

```rust
use std::io
```

> 默认情况下，Rust 设定了若干个会自动导入到每个程序**作用域**中的标准库内容，这组内容被称为 **预导入（prelude） 内容**。
> 如果你需要的类型不在预导入内容中，就必须使用 `use` 语句显式地将其引入作用域。

接下来，创建一个 变量（variable）来储存用户输入，像这样：

```rust
let mut guess = String::new();
```

> 等号的右边是 guess 所绑定的值，它是 `String::new` 的结果，这个函数会返回一个 `String` 的新实例。
> `String` 是一个标准库提供的**字符串类型**，它是 UTF-8 编码的可增长文本块。
> 
> `::` 语法表明 `new` 是 `String` 类型的一个 **关联函数（associated function）**。
> **关联函数**是针对某个**类型**实现的函数，在这个例子中的**类型**是 `String`。

总的来说，`let mut guess = String::new();` 这一行创建了一个可变变量，当前它绑定到一个新的 `String` 空实例上。

调用 `io` 库中的函数 `stdin`，用来处理用户输入:

```rust
io::stdin()
	.read_line(&mut guess)
```

用`std::io::stdin`函数，返回一个`Stdin`实例（这是一种代表**终端标准输入句柄**的类型）。

`.read_line(&mut guess)` 调用了标准输入句柄上的 `read_line` 方法，以获取用户输入。
这里将 `&mut guess` 作为参数传递给 `read_line` 函数，让其将用户输入储存到这个字符串中。

> `read_line` 函数的工作是，无论用户在标准输入中键入什么内容，都将其追加（不会覆盖其原有内容）到一个字符串中，**因此它需要字符串作为参数**。
> 这个字符串参数应该是**可变的**，以便 `read_line` 将用户输入附加上去。
> 
> `&` 表示这个参数是一个 **引用（reference）**，它允许多处代码访问同一处数据，而无需在内存中多次拷贝。

`read_line` 会将**用户输入**附加到传递给它的**字符串**中，但它也会返回一个类型为 `Result` 的值。

`Result` 是一种**枚举类型**，通常也写作 **enum**，它可以是多种可能状态中的一个。
我们把每种可能的状态称为一种 **枚举成员（variant）**。

`Result` 的成员是 `Ok` 和 `Err`，`Ok` 成员表示操作成功，内部包含**成功时产生的值**。
`Err` 成员则意味着操作失败，并且 Err 中包含**有关操作失败的原因或方式的信息**。

`Result` 的实例拥有 `expect` 方法。
如果 `io::Result` 实例的值是 `Err`，`expect` 会导致程序崩溃，并输出**当做参数传递给 `expect` 的信息**。
所以当 `read_line` 方法返回 `Err`，则可能是来源于底层操作系统错误的结果。

如果 `Result` 实例的值是 `Ok`，`expect` 会获取 `Ok` 中的值并原样返回。
在本例中，这个值是用户输入到标准输入中的字节数。

如果不调用 `expect`，程序也能编译，不过会出现一个警告：

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --> src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s

```

 > 警告我们没有使用 read_line 的返回值 Result，说明有一个可能的错误没有处理。
 > 消除警告的正确做法是实际去**编写错误处理代码**，但是在这里，我们就是希望程序在出现问题时**立即崩溃**，所以直接使用 `expect`。

```rust
println!("You guessed: {guess}");
```

`{}` 这对大括号是一个占位符。
当打印**变量的值**时，变量名可以写进大括号中。

当打印**表达式的执行结果**时，格式化字符串（format string）中大括号中留空，格式化字符串后跟逗号分隔的需要打印的表达式列表，其顺序与每一个空大括号占位符的顺序一致。即：

```rust
let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
```

# 生成秘密数字

接下来，需要生成一个秘密数字，好让用户来猜。
秘密数字应该每次都不同，这样重复玩才不会乏味；
范围应该在 1 到 100 之间，这样才不会太困难。

Rust 标准库中尚未包含随机数功能。
然而，Rust 团队还是提供了一个包含上述功能的 `rand` crate。

> crate 是一组 Rust **源代码文件**。
> 我们正在构建的项目是一个 二进制 crate，它生成一个**可执行文件**。
> `rand` crate 是一个 **库 crate**，**库 crate** 可以包含任意能被其他程序使用的代码，但是无法独立执行。
>
> [Crates.io](https://crates.io/) 是 Rust 生态系统中，人们发布其开源 Rust 项目的平台，供他人使用。

手动在`Cargo.toml`文件中增加：

```toml
[dependencies]
rand = "0.8.5"
```

代码：

```rust
use std::io;

use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}
```

> 新增了一行 `use rand::Rng;`。
> `Rng` 是一个 trait，它定义了随机数生成器应实现的方法，想使用这些方法的话，此 trait 必须在作用域中。

`rand::thread_rng` **函数**提供实际使用的**随机数生成器**：它位于**当前执行线程**的本地环境中，并从操作系统获取 seed。

接着调用随机数生成器的 `gen_range` 方法。
这个方法由 `use rand::Rng` 语句引入到作用域的 `Rng` **trait** 定义。

`gen_range` 方法获取一个**范围表达式（range expression）** 作为参数，并生成一个在此范围之间的随机数。
这里使用的这类范围表达式使用了 `start..=end` 这样的形式，它对上下边界均为闭区间，所以需要指定 `1..=100` 来请求一个 1 和 100 之间的数。

> **注意**：你不可能凭空就知道应该 `use` 哪个 trait 以及该从 crate 中调用哪个方法，因此每个 crate 有使用说明文档。

> Cargo 的另一个很棒的功能是运行 `cargo doc --open` 命令来构建所有本地依赖提供的文档并在浏览器中打开。
> 例如，假设你对 `rand` crate 中的其他功能感兴趣，你可以运行 `cargo doc --open` 并点击左侧导航栏中的 `rand`。

# 比较猜测数字和秘密数字

代码：

```rust
// 暂时还不能编译
use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    // --snip--

    println!("You guessed: {guess}");

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
```

从标准库引入了一个叫做 `std::cmp::Ordering` 的类型到作用域中。

`Ordering` 也是一个**枚举类型**:
- `Less`
- `Greater`
- `Equal`

这是比较两个值时可能出现的三种结果。

```rust
match guess.cmp(&secret_number) {
	Ordering::Less => println!("Too small!"),
	Ordering::Greater => println!("Too big!"),
	Ordering::Equal => println!("You win!"),
}
```

一个 `match` 表达式由 **分支（arms）** 构成。
一个分支包含一个 **模式（pattern）** 和 “当表达式开头的值与分支模式相匹配” 时应该执行的代码。

Rust 获取提供给 `match` 的值并挨个检查每个分支的模式。
`match` 结构和模式是 Rust 中强大的功能，它体现了代码可能遇到的多种情形，并确保对所有情况作出处理。

`let guess = String::new()` 中Rust 推断出 `guess` 应该是 `String` 类型。
另一方面，`secret_number`，是数字类型。
这里的编译错误的原因在于 Rust 不会比较字符串类型和数字类型。

```rust
let mut guess = String::new();

io::stdin()
	.read_line(&mut guess)
	.expect("Failed to read line");

let guess: u32 = guess.trim().parse().expect("Please type a number!");

println!("You guessed: {guess}");

match guess.cmp(&secret_number) {
	Ordering::Less => println!("Too small!"),
	Ordering::Greater => println!("Too big!"),
	Ordering::Equal => println!("You win!"),
}
```

Rust 允许用一个新值来 **遮蔽 （Shadowing）** `guess` 之前的值。
这个功能经常用于 ***将一个类型的值转换为另一个类型的值***。

```rust
let guess: u32 = guess.trim().parse().expect("Please type a number!");
```

`String` 实例的 `trim` 方法会去除字符串开头和结尾的空白字符。

用户必须输入 `enter` 键才能让 `read_line` 返回并输入他们的猜想，这将会在字符串中增加一个换行（newline）符。
例如，用户输入 5 并按下 `enter`，guess 看起来像这样：`5\n` 或者 `5\r\n`。
`trim` 方法会消除 `\n` 或者 `\r\n`，结果只留下 5。

**字符串**的 `parse` 方法 将字符串转换成**其他类型**。
我们需要告诉 Rust 具体的数字类型，这里通过 `let guess: u32` 指定。

`parse` 方法非常容易出错。
例如，字符串中包含 `A👍%`，就无法将其转换为一个数字。
因此，`parse` 方法返回一个 `Result` 类型。

用 `expect` 方法处理 `Result`。
- 如果 `parse` 不能从字符串生成一个数字，返回一个 `Result` 的 `Err` 成员时，`expect` 会使游戏崩溃并打印附带的信息。
- 如果 `parse` 成功地将字符串转换为一个数字，它会返回 `Result` 的 `Ok` 成员，然后 `expect` 会返回 `Ok` 值中的数字。

# 使用循环允许多次猜测

代码：

```rust
use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    println!("Guess the number!");
    let secret_number = rand::thread_rng().gen_range(1..=100);
    println!("The secret number is: {secret_number}");
    loop {
        println!("Please input your guess");
        let mut guess = String::new();
        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");
        println!("You guessed: {guess}");
        let guess: u32 = guess.trim().parse().expect("Please type a number!");
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```

# 处理无效输入

代码：

```rust
// --snip--

io::stdin()
	.read_line(&mut guess)
	.expect("Failed to read line");

let guess: u32 = match guess.trim().parse() {
	Ok(num) => num,
	Err(_) => continue,
};

println!("You guessed: {guess}");

// --snip--
```

将 `expect` 调用换成 `match` 语句，以从遇到错误就崩溃转换为处理错误。
如果 `parse` 能够成功地将字符串转换为一个数字，它会返回一个包含结果数字的 `Ok`。

这个 `Ok` 值与 `match` 第一个分支的模式相匹配，该分支对应的动作返回 Ok 值中的数字 `num`，最后如愿变成新创建的 `guess` 变量。

如果 `parse` 不能将字符串转换为一个数字，它会返回一个包含更多错误信息的 `Err`。
`Err` 值不能匹配第一个 `match` `Ok(num)` 模式，但是会匹配第二个分支的 `Err(_)` 模式：`_` 是一个通配符值，本例中用来匹配所有 `Err` 值，不管其中有何种信息。
所以程序会执行第二个分支的动作，`continue` 意味着进入 `loop` 的下一次循环，请求另一个猜测。

# 最终代码

```rust
use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("Please input your guess");

        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        println!("You guessed: {guess}");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => {
                println!("Please type a number!");
                continue;
            }
        };

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```