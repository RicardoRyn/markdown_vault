# 所有权机制

所有程序都必须管理其运行时使用计算机内存的方式。

- 一些语言中具有垃圾回收机制，在程序运行时有规律地寻找不再使用的内存；
- 在另一些语言中，程序员必须亲自分配和释放内存。
- Rust则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。

## 栈与堆

**栈**和**堆**都是代码在运行时可供使用的内存，但是它们的结构不同。

---

**栈 stack**

栈以放入值的顺序存储值并以相反顺序取出值。
这也被称作 后进先出（last in, first out）。
增加数据叫做 **入栈（pushing onto the stack）**，而移出数据叫做 **出栈（popping off the stack）**。

**栈**中的所有数据都必须占用**已知且固定的大小**。
在编译时大小未知或大小可能变化的数据，要改为存储在**堆**上。

---

**堆 heap**

**堆**是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。
内存分配器（memory allocator）在堆的某处找到一块足够大的空位，
把它标记为已使用，并返回一个表示该位置地址的 **指针（pointer）**。

这个过程称作 在堆上分配内存（allocating on the heap），
有时简称为 **分配（allocating）**（将数据推入栈中并不被认为是分配）。

因为指向放入堆中数据的**指针**是**已知的并且大小是固定的**，你可以将该指针存储在栈上，不过当需要实际数据时，必须访问指针。
想象一下去餐馆就座吃饭。当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。
如果有人来迟了，他们也可以通过询问来找到你们坐在哪。

---

**入栈比在堆上分配内存要快**，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。
相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。

**访问堆上的数据比访问栈上的数据慢**，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快。

当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被**压入栈中**。
当函数结束时，这些值被**移出栈**。

## 所有权概念

所有权要解决的问题：
跟踪哪部分代码正在使用堆上的哪些数据，**最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间**。

> 一旦理解了所有权，你就不需要经常考虑栈和堆了。
> 不过明白了所有权的主要目的就是管理堆数据，能够帮助解释为什么所有权要以这种方式工作。

## 所有权规则

记住这些规则：

1. Rust 中的每一个值都有一个 **所有者**。
2. 值在任一时刻有且只有一个所有者。
3. 当所有者离开作用域，这个值将被丢弃。

前面介绍的类型都是已知大小的，可以存储在栈中，并且当离开作用域时被移出栈。
如果代码的另一部分需要在不同的作用域中使用相同的值，可以快速简单地复制它们来创建一个新的独立实例。

现在需要寻找一个存储在**堆**上的数据来探索 Rust 是如何知道该在何时清理数据的，而 `String` 类型就是一个很好的例子。

我们已经见过字符串字面值，即被硬编码进程序里的字符串值。

> 字面值（literal）就是直接写在代码里的固定值。
> 它和“变量”“计算结果”不同，不需要运行时再去计算。
>
> 1. 42 → 整数字面值
> 2. 3.14 → 浮点数字面值
> 3. "hello world" → 字符串字面值
> 4. true / false → 布尔字面值

字符串字面值是很方便的，不过它们并不适合使用文本的每一种场景，因为：

1. 它们是不可变的。
2. 并非所有字符串的值都能在编写代码时就知道。

Rust 有另一种字符串类型，`String`。
这个类型管理被分配到**堆**上的数据，所以能够存储在编译时未知大小的文本。

可以使用 `from` 函数基于字符串字面值来创建 `String`，如下：

```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() 在字符串后追加字面值

println!("{s}"); // 将打印 `hello, world!`
```

> 这两个冒号 `::` 是运算符，允许将特定的 `from` 函数置于 `String` 类型的 **命名空间（namespace）** 下，
> 而不需要使用类似 `string_from` 这样的名字。

对于**字符串字面值**，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。
这使得字符串字面值快速且高效。

但是我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。

对于 String 类型，为了支持一个可变，可增长的文本片段，需要在**堆**上分配一块在编译时未知大小的内存来存放内容：

1. 必须在运行时向**内存分配器**（memory allocator）请求内存。
2. 需要一个当我们处理完 `String` 时将内存返回给分配器的方法。

第一部分由我们完成：
当调用 `String::from` 时，它的实现 (implementation) 请求其所需的内存。

第二部分实现起来不同语言不一样：

- 在有 垃圾回收（garbage collector，GC）的语言中，GC 记录并清除不再使用的内存，而我们并不需要关心它。
- 在大部分没有 GC 的语言中，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。

从历史的角度上说正确处理内存回收曾经是一个困难的编程问题：

- 如果忘记回收了会浪费内存。
- 如果过早回收了，将会出现无效变量。
- 如果重复回收，这也是个 bug。

我们需要精确的为一个 allocate 配对一个 free。
Rust 采取了一个不同的策略：内存在**拥有它的变量离开作用域后**就被自动释放。

在上例中，当 `s` 离开作用域的时候。
当变量离开作用域，Rust 为我们调用一个特殊的函数。
这个函数叫做 `drop`，在这里 `String` 的作者可以放置释放内存的代码。
Rust 在结尾的 `}` 处自动调用 `drop`。

```rust
let x = 5;
let y = x;

println!("x = {x}, y = {y}"); // 正常运行
```

> 将 5 绑定到 `x`；接着生成一个值 `x` 的拷贝并绑定到 `y`。
> 现在有了两个变量，`x` 和 `y`，都等于 5。
> 这两个 5 被压入了栈中。

```rust
let s1 = String::from("hello");
let s2 = s1;
```

`String` 由三部分组成，如图左侧所示：

1. 一个指向存放字符串内容内存的**指针 ptr**。
2. 一个**长度 len**，长度表示 `String` 的内容当前使用了多少字节的内存。
3. 一个**容量 capacity**，容量是 `String` 从分配器总共获取了多少字节的内存。

这一组数据存储在栈上。

当我们将 `s1` 赋值给 `s2`，`String` 的数据被复制了，这意味着我们从栈上拷贝了它的**指针、长度、容量**。
但是我们并没有复制**指针指向的堆上数据**。

当变量离开作用域后，Rust 自动调用 `drop` 函数并清理变量的堆内存。
由于 `s1` 和 `s2` 两个数据**指针**指向了同一位置。
这就有了一个问题：当 s2 和 s1 离开作用域，它们都会尝试释放相同的内存。
这是一个叫做 **二次释放（double free）** 的错误。
两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。

为了确保内存安全，在 `let s2 = s1;` 之后，Rust 认为 `s1` 不再有效。
因此 Rust **不需要**在 `s1` 离开作用域后清理任何东西。

没有 `s1`，以下代码就会报错：

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{s1}"); // 这里导致报错
println!("{s2}");
```

> 如果你在其他语言中听说过术语 **浅拷贝（shallow copy）** 和 **深拷贝（deep copy）**，那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。
> 不过因为 Rust 同时使第一个变量无效了，这个操作被称为 **移动（move）**。
> 上面的例子可以解读为 `s1` 被移动到了 `s2` 中。

这样就解决了问题！这就是 **所有权**！
因为只有 `s2` 是有效的，当其离开作用域，它就释放自己的内存，完毕。

> 另外，Rust 永远也不会自动创建数据的 “深拷贝”。
> 因此，任何自动的复制都可以被认为是对运行时性能影响较小的。

当你给一个已有的变量赋一个全新的值时，Rust 将会立即调用 `drop` 并释放原始值的内存:

```rust
let mut s = String::from("hello");
s = String::from("ahoy");

println!("{s}, world!");
```

如果我们 **确实** 需要**深复制** `String` 中**堆**上的数据，而不仅仅是**栈**上的数据，可以使用一个叫做 `clone` 的常用方法：

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {s1}, s2 = {s2}");
```

## 只在栈上的数据：拷贝

以下代码是没有错误的：

```rust
let x = 5;
let y = x; // 等价于`let y = x.clone();`

println!("x = {x}, y = {y}"); // 正常运行
```

原因是像**整型**这样的在编译时**已知大小的**类型被整个存储在栈上，所以拷贝其实际的值是快速的。
没有深浅拷贝的区别，所以这里调用 `clone` 并不会与通常的浅拷贝有什么不同，我们可以不用管它。

> Rust 有一个叫做 `Copy` trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。
> 如果一个类型实现了 `Copy` trait，那么一个旧的变量在将其赋值给其他变量后仍然有效。
>
> Rust **不允许**自身或其任何部分实现了 `Drop` trait
> （意思是这个类型的值离开作用域时有特殊情况需要处理）
> 的 **类型** 使用 `Copy` trait。
>
> 如果我们对这种类型使用 `Copy` 注解，将会出现一个编译时错误。

任何一组简单标量值的组合都可以实现 `Copy`，任何不需要分配内存或某种形式资源的类型都可以实现 `Copy` 。
例如：

1. 所有整数类型，比如 `u32`。
2. 布尔类型，`bool`，它的值是 `true` 和 `false`。
3. 所有浮点数类型，比如 `f64`。
4. 字符类型，`char`。
5. 元组，**当且仅当**其包含的类型也都实现 `Copy` 的时候。比如，`(i32, i32)` 实现了 `Copy`，但 `(i32, String)` 就没有。

## 所有权与函数

将值传递给函数与给变量赋值的原理相似。
向函数传递值可能会移动或者复制，就像赋值语句一样:

```rust
fn main() {
    let s = String::from("hello"); // s 进入作用域

    takes_ownership(s); // s 的值移动到函数里 ...
                        // ... 所以到这里不再有效

    let x = 5; // x 进入作用域

    makes_copy(x); // x 应该移动函数里，
                   // 但 i32 是 Copy 的，
    println!("{}", x); // 所以在后面可继续使用 x
} // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 没有特殊之处

fn takes_ownership(some_string: String) {
    // some_string 进入作用域
    println!("{some_string}");
} // 这里，some_string 移出作用域并调用 `drop` 方法。
  // 占用的内存被释放

fn makes_copy(some_integer: i32) {
    // some_integer 进入作用域
    println!("{some_integer}");
} // 这里，some_integer 移出作用域。没有特殊之处
```

## 返回值与作用域

返回值也可以转移所有权:

```rust
fn main() {
    let s1 = gives_ownership(); // gives_ownership 将它的返回值传递给 s1

    let s2 = String::from("hello"); // s2 进入作用域

    let s3 = takes_and_gives_back(s2); // s2 被传入 takes_and_gives_back,
                                       // 它的返回值又传递给 s3
} // 此处，s3 移出作用域并被丢弃。s2 被 move，所以无事发生
  // s1 移出作用域并被丢弃

fn gives_ownership() -> String {
    // gives_ownership 将会把返回值传入
    // 调用它的函数

    let some_string = String::from("yours"); // some_string 进入作用域

    some_string // 返回 some_string 并将其移至调用函数
}

// 该函数将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String {
    // a_string 进入作用域

    a_string // 返回 a_string 并移出给调用的函数
}
```

**变量**的所有权总是遵循相同的模式：
将值赋给另一个变量时它会移动。
当持有**堆中数据值**的变量离开作用域时，其值将通过 `drop` 被清理掉，除非数据被移动为另一个变量所有。

如果我们想要**函数**使用一个值但**不获取所有权**。
因为我们还要接着使用该值，并且也可能想返回函数体中产生的一些数据。
这时候可以使用**元组**来返回多个值:

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{s2}' is {len}.");
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() 返回字符串的长度

    (s, length)
}
```

> 上面的场景其实非常常见。
> 但是这种写法太“形式主义”，Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 **引用（references）**。

# 引用与借用

## 引用

在上面的例子中。
必须将 `String` 返回给调用函数，以便 `main` 在调用 `calculate_length` 后仍能使用 `String`。

实际上，更正确的做法是，直接提供一个 `String` 值的**引用（reference）。**

**引用（reference）**像一个指针，因为它是一个地址，以由此访问储存于该地址的属于其他变量的数据。
与指针不同，引用在其生命周期内**保证指向某个特定类型的有效值**。

定义并使用一个（新的）`calculate_length` 函数，它以一个**对象的引用**作为参数而不是获取值的所有权：

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{s1}' is {len}.");
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

> 传递 `&s1` 给 `calculate_length`，同时在函数定义中，我们获取 `&String` 而不是 `String`。
> 这些 `&` 符号就是 **引用**，它们允许你**使用值但不获取其所有权**。
> 变量 `s` 有效的作用域与函数参数的作用域一样，当 s 停止使用时并不丢弃引用指向的数据，因为 s 并没有所有权。
>
> 我们将“**创建一个引用的行为**”称为 **借用（borrowing）**。
> 正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。
> 当你使用完后，必须还回去。
> 因为并不拥有它的所有权。

无法修改借用的变量，会报错：

```rust
// 以下代码会报错
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world"); // 引用是不可变的
}
```

> **引用**是不可变的。

## 可变引用

将 `s` 改为 `mut`。
然后在调用 `change` 函数的地方创建一个**可变引用** `&mut s`，并更新函数签名以接受一个可变引用 `some_string: &mut String`。
这就非常清楚地表明，`change` 函数将改变它所借用的值。

```rust
fn main() {
    let mut s = String::from("hello");

    println!("{s}"); // hello

    change(&mut s);

    println!("{s}"); // hello, world
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
} // 注意这个函数没有返回任何值，他只是更改了他所借用的值
```

**可变引用**有一个很大的限制：
如果你有一个对该变量的**可变引用**，直到使用完成，**不能**再创建对该变量的引用。
这些尝试创建两个 `s` 的可变引用的代码会失败：

```rust
// 以下代码会报错
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s; // r1还没用呢，就又借给r2了

println!("{r1}, {r2}");
```

不能在同一时间多次将 `s` 作为**可变变量**借用。

第一个可变的借入在 `r1` 中，并且必须持续到在 `println!` 中使用它。
但是在**那个可变引用的创建和它的使用之间**，我们又尝试在 `r2` 中创建另一个**可变引用**，该引用借用与 `r1` 相同的数据，这是被禁止的。

这个限制的好处是 Rust 可以在编译时就避免**数据竞争**。
**数据竞争（data race）**类似于竞态条件，它可由这三个行为造成：

1. 两个或更多指针同时访问同一数据。
2. 至少有一个指针被用来写入数据。
3. 没有同步数据访问的机制。

我们也**不能**在拥有不可变引用的同时拥有可变引用。

```rust
let mut s = String::from("hello");

let r1 = &s; // 没问题
let r2 = &s; // 没问题
let r3 = &mut s; // 大问题

println!("{}, {}, and {}", r1, r2, r3);
```

> 不可变引用的借用者可不希望在借用时值会突然发生改变！
> 但是多个不可变引用是可以的，因为没有哪个只能读取数据的引用者能够影响其他引用者读取到的数据。

```rust
let mut s = String::from("hello");

let r1 = &s; // 没问题
let r2 = &s; // 没问题
println!("{r1} and {r2}");
println!("{r1} and {r2}, again");

let r3 = &mut s; // 没问题，但是此位置之后 r1 和 r2 不再使用
println!("{r3}");

```


## 悬垂引用（Dangling References）


在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个**悬垂指针（dangling pointer）**，指向可能已被分配给其他用途的内存位置的指针。

相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂引用：
当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。

尝试创建一个悬垂引用：

```rust
// 以下代码会报错
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

报错信息：

```
this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
```

> 这个函数的返回类型包含一个借用的值，但没有任何值可以被借用。
> 换句话说，你试图返回一个 **指向局部变量（即 `s`）的引用**，而该局部变量在函数返回时就会被释放。
> 所以 Rust 不允许这样做。

修改：

```rust
fn main() {
    let reference_to_nothing = dangle();
    println!("{reference_to_nothing}")
}

fn dangle() -> String {
    let s = String::from("hello");

    s
}
```

## 总结

- 在同一时间内，要么有 一个可变引用（独占写），要么有 多个不可变引用（共享读）。
- 引用必须总是有效的。

