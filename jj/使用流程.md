# 使用流程

我要成为 `jj` 糕手。

## 事先准备

配置 `jj`

```bash
jj config path --user # 查看配置文件路径

# 基本配置
jj config set --user user.name "Ricardo_T8"                # 设置用户名
jj config set --user user.email "RicardoRyn1317@gmail.com" # 设置用户邮箱
jj config set --user core.editor "nvim"                    # 设置默认编辑器
jj config set --user ui.pager :builtin                     # 设置默认pager

# 如果更改用户或者邮箱，需要以下命令更新
jj metaedit --update-author

# (可选)
jj config set --user git.push-new-bookmarks true # 推送新的书签无须加`--allow-new`
jj config set --user ui.pager :builtin           # 使用内置分页器
```

## 常规操作

### 初始化仓库

创建仓库

```bash
jj git init 仓库名 --colocate # -colocate 表示 jj 与 git 共存
jj git remote add origin git@github.com:用户名/仓库名.git
jj git remote list
# 或者
jj git clone git@github.com:RicardoRyn/仓库名.git
```

显示信息

```bash
jj log
jj log -r :: # 查看所有change链
jj log -r "heads(::)" # 查看所有分支的头部

jj show @
jj show main@origin
```

显示操作信息

```bash
jj op log
jj op log --limit 2           # 查看最近2个操作
jj op log --limit 2 --summary # 显示最近对仓库的变更
jj op log --limit 2 --patch   # 显示每次操作中具体的文件改变

jj op show 操作名 # 查看单个操作引起的变化
jj op show 操作名 --summary
jj op show 操作名 --patch
```

### 本地操作

提交

```bash
jj commit
jj commit -m "feat: 初始化仓库"

# jj commit 等价于 jj new 加 jj describe
```

添加书签

```bash
jj bookmark create 书签名 -r 修订名
```

推送新的书签

```bash
jj git push --bookmark 书签名 -N # -N 表示推送新的书签
```

推送已有的书签，**每次push之前，都要移动书签**

```bash
jj bookmark move 书签名 -t 修订名 # 这里是 -t 不是 -r
jj git push
```

创建其他书签，并推送

```bash
jj git push -c 修订名 # -c 表示 --change，会自动在远程仓库创建名为`push-修订名`的书签
```

从远程仓库获取更新

```bash
jj git fetch
```

删除某个修订，如果它连带某个书签，会一起删除

```bash
jj abandon 修订名
jj abandon 'description("Experiment")' # 只删除描述带“Experiment”的change
```

书签仅在本地被删除，将已删除的书签与远程仓库同步

```bash
jj git push --delete
```

### 合并操作

合并多个分支上的修订

```bash
jj new 修订1 修订2
```

变基，从一个"base"（某个祖先提交）提取某个修订，并将其移动到另一个不同的"base"之上

```bash
jj rebase -d 修订名 # -d 表示 --destination
```

### 其他操作

停止追踪指定文件

```bash
echo "rm_rjx.txt" >.gitignore
jj file untrack rm_rjx.txt
```

跳到到指定修订，可查看当前状态下的文件

```bash
jj new 修订名
```

> 这一步操作本质上是在指定修订后创建一个空的子修订，且该子修订位于新的分支
> 如果不做任何修改，在离开该空的子分支的时候，`jj` 会自动删除该空子分支

`jj` 中的书签分为：

- 追踪 (`书签名`)
- 未追踪 (仅`书签名@origin`)

若书签被标记为追踪状态， `jj git fetch` 会自动保持本地与远程版本同步。
新建书签并推送到远程后，会自动转为追踪状态。

克隆仓库或者初始化某个git仓库时，某些书签 (git的语境下就是分支) 不会被追踪。
需要手动将书签设为追踪状态：

```bash
jj bookmark track 书签名@origin
```

## 高级操作

### split

`jj split` 将当前修订拆分成2个修订，自动打开差异编辑器

> 在差异编辑器中：
> `F`: 展开/折叠文件
> `hl`: 展开折叠区域
> `jk`: 上下
> `<space>`: 选中区域
> `c`: 保存退出
> `q`: 不保存退出

注意：

1. 选中的区域将拆分到子修订中
2. 先为当前修订修改描述
3. 再为拆分出的子修订修改描述

### sqush

`jj sqush -i` 将当前修订合并到上一个修订，`-i` 表示启动交互界面，即打开差异编辑器

1. 选中的区域将合并到父修订中
2. 如果合并了所有的内容，则描述也会合并到父修订中，并自动创建一个新的空修订

### 恢复/回滚

`jj undo` 回滚最近的一次操作
`jj undo 操作名` 回滚指定操作

注意：

1. `jj undo` 虽然会回滚操作，但是操作日志中的信息不会被删除
2. `jj undo` 本身也会被记录到回滚信息中
3. 可以 `jj undo 操作名` 多次，但是只有第一次操作才有意义，后续操作只会增加日志，没有实质性改变
4. 由于`jj undo` 本身也会被记录，所以连续 `jj undo ` 偶数次，除了增加日志外，也不会有实质性改变

使用 `jj op restore` 来回滚多个操作

`jj op restore 操作名` 会创建一个“将仓库恢复到对应状态”的新操作
如果我们指定的操作是`x`，则`@`和`x+`之间的所有操作都会被undo

> 注意区分:
> `jj undo 操作名` 是回滚操作 `操作名`
> `jj op restore 操作名` 是回滚 `操作名` 之后的所有操作

建议在 `jj op restore` 之前，先使用 `jj log --at-op 操作名 --patch` 查看当时的修订状态

恢复被修改的文件，即取消对文件的修改：

```bash
jj restore README.md
jj restore # 恢复所有被修改的文件

# 将指定文件恢复到指定change的状态
jj restore -f 'description("Fix loop syntax")' hello.py # -f 表示 --from
```

## 冲突

```bash
jj new main @-
```

冲突文件中显示：

```text
<<<<<<< Conflict 1 of 1
%%%%%%% Changes from base to side #1
 print("Hello, world!")
+print("Hallo, Welt!")
+print("Bonjour, le monde!")
+++++++ Contents of side #2
for _ in range(10):
    print("Hello, world!")
>>>>>>> Conflict 1 of 1 ends
```

> `%%%%%%% Changes from base to side #1` 为标题
> `base` 指合并操作中两个分支开始分叉的那个提交点
> `side #1` 指 `jj new main @-`中第1个change，即`main`
> `side #2` 指 `jj new main @-`中第2个change，即`@-`
> 所有行都以 `空格`、`-`、`+` 作为前缀
