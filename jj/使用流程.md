# 使用流程

## 事先准备

`jj config set --user user.name "Ricardo_T8"` # 设置用户名
`jj config set --user user.email "RicardoRyn1317@gmail.com"` # 设置用户邮箱
`jj config set --user core.editor "nvim"` # 设置默认编辑器
`jj config set --user ui.pager :builtin` # 设置默认pager

如果更改用户或者邮箱，需要以下命令更新
`jj metaedit --update-author`

可选
`jj config set --user git.push-new-bookmarks true` # 推送新的书签无须加`--allow-new`
`jj config set --user ui.pager :builtin`

## 初始化仓库

创建仓库

```bash
jj git init jj-tutorial
jj git remote add origin git@github.com:RicardoRyn/jj-tutorial.git
jj git remote list
# 或者
jj git clone git@github.com:RicardoRyn/jj-tutorial.git
```

显示信息

```bash
jj log
jj log -r :: # 查看所有change链

jj show @ # @ 可以略不写
jj show main@origin
```

## 本地操作

提交

```bash
jj commit
jj commit -m "feat: 初始化仓库"

# jj commit 等价于 jj new 加 jj describe
```

添加bookmark

```bash
jj bookmark create main -r @-
```

推送新的bookmark

```bash
jj git push --bookmark main -N # -N 表示推送新的书签
```

推送已有的bookmark
**每次push之前，都要移动bookmark**

```bash
jj bookmark move main -t @- # 这里是 -t 不是 -r
jj git push
```

创建其他bookmark，并推送

```bash
jj git push -c @- # -c 表示 --change，会在远程仓库创建名为`push-<change ID>`的分支
```

从远程仓库获取更新

```bash
jj git fetch
```

删除某个change，如果它连带某个bookmark，会一起删除

```bash
jj abandon ChangeID
jj abandon 'description("Experiment")' # 只删除描述带“Experiment”的change
```

书签仅在本地被删除，将已删除的书签与远程仓库同步

```bash
jj git push --delete
```

## 合并操作

merge多个change

```bash
jj new main @-
```

rebase，从一个"base"（某个祖先提交）提取某个change，并将其移动到另一个不同的"base"之上。

```bash
jj rebase -d main@origin # -d 表示 --destination
```

## 其他操作

撤销 和 反撤销

```bash
jj undo
jj redo
```

停止追踪指定文件

```bash
echo "rm_rjx.txt" >.gitignore
jj file untrack rm_rjx.txt
```

跳到到指定change，可查看当前状态下的文件

```bash
jj new main
```

Jujutsu 中的书签分为：

- 追踪 (<bookmark name>)
- 未追踪 (仅<bookmark name>@origin)

若书签被标记为追踪状态， `jj git fetch` 会自动保持本地与远程版本同步。
新建书签并推送到远程后，会自动转为追踪状态。

clone 仓库时，只有 `main` 书签会自动设为追踪状态。

将书签设为追踪状态：

```bash
jj bookmark track push-zkwmvzlqluot@origin
```

恢复被修改的文件，即取消对文件的修改：

```bash
jj restore README.md
jj restore # 恢复所有被修改的文件

# 将指定文件恢复到指定change的状态
jj restore -f 'description("Fix loop syntax")' hello.py # -f 表示 --from
```

## 冲突

```bash
jj new main @-
```

冲突文件中显示：

```text
<<<<<<< Conflict 1 of 1
%%%%%%% Changes from base to side #1
 print("Hello, world!")
+print("Hallo, Welt!")
+print("Bonjour, le monde!")
+++++++ Contents of side #2
for _ in range(10):
    print("Hello, world!")
>>>>>>> Conflict 1 of 1 ends
```

> `%%%%%%% Changes from base to side #1` 为标题
> `base` 指合并操作中两个分支开始分叉的那个提交点
> `side #1` 指 `jj new main @-`中第1个change，即`main`
> `side #2` 指 `jj new main @-`中第2个change，即`@-`
> 所有行都以 `空格`、`-`、`+` 作为前缀
