# 科研式项目管理

“脚本化、零散化，但又需要共享函数”的工作流，在科研领域非常典型。

但 Python 的导入机制默认是为软件开发设计的，这就导致：**脚本跑起来找不到隔壁文件夹里的模块**。

对于使用 `uv` 管理的项目，最优雅、最符合现代 Python 标准（且不需要你写恶心的 `sys.path.append` 代码）的做法是：**将你的项目本身安装为“可编辑模式” (Editable Install)**。

简单来说，就是告诉 Python 环境：“嘿，`src` 文件夹里的东西也是一个包，名字叫 `self_fmri`，无论我在哪里运行脚本，你都要能找到它。”

## 第一步：确认目录结构

依旧推荐 `src` 布局：

```text
self_fmri/             <-- 项目根目录
├── pyproject.toml     <-- 核心配置文件
├── src/
│   └── self_fmri/     <-- 真正的包代码
│       ├── __init__.py    <-- 建议加上，虽然空着也行
│       ├── utils/
│       │   ├── __init__.py <-- 必须有
│       │   ├── plot.py
│       │   └── calc.py
│       └── scripts/
│           ├── __init__.py <-- 建议加上
│           ├── a.py
│           └── b.py
```

**注意：请确保 `utils` 和 `src/self_fmri` 下都有 `__init__.py` 文件（空的就行），这是告诉 Python “这是一个可以被导入的包”的标志。**

## 第二步：配置 pyproject.toml

这是最关键的一步。你需要确保 `pyproject.toml` 里声明了你的项目是一个包。

打开项目根目录下的 `pyproject.toml`，确保内容包含以下部分（如果你是用 `uv init` 生成的，大部分应该已经有了）：

```toml
[project]
name = "self-fmri"   # 项目名字
version = "0.1.0"
description = "My fMRI analysis project"
readme = "README.md"
requires-python = ">=3.11"
dependencies = [
    "numpy",    # 你需要的其他依赖
    "pandas",
    "nibabel",
]

# ！！！重点！！！
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

```

**告诉 Python 如何"打包"你的项目**

`requires = ["hatchling"]`

- 告诉打包工具需要什么依赖才能构建你的包
- `hatchling` 是一个构建后端（build backend），负责把你的代码打包成可安装的格式
- 其他常见选项：`setuptools`、`flit`、`pdm-backend` 等

`build-backend = "hatchling.build"`

- 指定使用哪个构建后端
- `hatchling.build` 是 Hatch 项目的构建系统
- 它知道如何找到 `src/self_fmri/` 并正确打包

| 没有说明书                             | 有说明书                            |
| -------------------------------------- | ----------------------------------- |
| uv: "这个项目怎么安装？不知道，跳过吧" | uv: "哦，用 hatchling 来构建"       |
| Python: "找不到 self_fmri"             | Python: "找到了！在 src/self_fmri/" |

## 第三步：执行同步 (The Magic Step)

在终端中，进入项目根目录，运行：

```bash
uv sync
```

`uv` 会读取 `pyproject.toml`，它发现这个项目本身也是一个包，于是它会把你的 `src` 目录以**可编辑模式**安装到虚拟环境中。

这意味着：**Python 此时已经把 `self_fmri` 当作像 `numpy` 一样的内置库了。**

## 第四步：在脚本中优雅地导入

现在，无论是在 `scripts/a.py` 还是 `scripts/b.py` 中，你都不需要关心文件的相对路径，直接用**绝对路径**导入即可。

在 `self_fmri/src/self_fmri/scripts/a.py` 中：

```python
import numpy as np
from self_fmri.utils.calc import calc2

# 就像导入第三方库一样导入你自己的 utils
from self_fmri.utils.plot import plot1


def main():
    data = np.random.rand(100)
    # 调用函数
    result = calc2(data)
    plot1(result)
    print("Analysis A finished!")


if __name__ == "__main__":
    main()
```

## 第五步：运行

现在，你可以用你习惯的方式运行脚本，绝对不会报错：

```bash
# 在项目根目录下
uv run src/self_fmri/scripts/a.py
```

或者哪怕你进入了 scripts 文件夹运行也行：

```bash
cd src/self_fmri/scripts
uv run a.py
```

## 为什么这样做最优雅？

1.  **一劳永逸**：你不需要在每个脚本开头写 `sys.path.append("../../")` 这种丑陋且容易因为文件移动而失效的代码。
2.  **符合直觉**：你在导入时也是写的 `from self_fmri.utils ...`，这非常符合人的认知逻辑——从我的项目里拿工具。
3.  **即时生效**：因为是“可编辑安装”，当你修改了 `utils/plot.py` 里的代码，再次运行 `a.py` 时，改动是立即生效的，不需要重新安装。
4.  **IDE 友好**：VSCode 或 PyCharm 能够完美识别这种结构，为你提供代码补全和跳转功能。

## 总结

1.  保持 `src` 结构。
2.  确保 `pyproject.toml` 配置正确。
3.  运行一次 `uv sync` 把项目“安装”进环境。
4.  在脚本里使用 `from self_fmri.utils.xxx import yyy`。
