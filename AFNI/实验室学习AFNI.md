

在打开afni的UI界面里的3张`image`里，有个`Mont`选项，打开：

- `Across`选择10
- `Down`选择10
- `Spacing`表示每张slice间的间隔

`set`后可以同时呈现 10×10共100张slice

![image.png](https://i.loli.net/2021/11/04/kIE4JNb8jmfsyZH.png)

图像右边的数字可以调整透明度，可以用来对比结构像和功能像的配准情况

脚本文件前面可以加个@表示这是一个脚本，而不是什么普通文本

---

Dicombrowser里看到的信息也不完全正确，最好还是用`3dinfo`确认一下

本来数据类型应该是`short`类型，有时候会出现`float类型`，而`float`比`short`数据大了一倍

`3dinfo`命令打印的最后几行可以看到数据储存的类型是`short`还是`float`

![image.png](https://i.loli.net/2021/11/04/N5PmW1FiJwGzqYh.png)

---

`to3d 20211009_T2_S000_EC.MR.HEAD_FMRI.0003.*.IMA`可以把这些文件重构，并且可以修改方向

有时候猴子图像的方向会出现错误，可以在这里更改

![image.png](https://i.loli.net/2021/11/04/gUTxIa43mFN89w7.png)

---

在输命令的时候可以用`>&`来保存即将打印的各种信息

例如键入afni会打印一些文本，可以用以下命令来保存：

```bash
afni >& test.txt
```

所以在跑一些长命令的时候要学会自己保存打印信息，例如预处理脚本：

```bash
./proc.S000_20211009 >& demo.txt
```

---

```bash
#!/bin/tcsh -xef

echo "auto-generated by afni_proc.py, Sat Nov  6 01:03:23 2021"
echo "(version 6.45, July 19, 2019)"
echo "execution started: `date`"

# to execute via tcsh: 
#   tcsh -xef ./proc.S001_20191218 |& tee ./output.proc.S001_20191218
# to execute via bash: 
#   tcsh -xef ./proc.S001_20191218 2>&1 | tee ./output.proc.S001_20191218

# =========================== auto block: setup ============================
# script setup

# take note of the AFNI version
afni -ver

# check that the current AFNI version is recent enough
afni_history -check_date 27 Jun 2019
if ( $status ) then
    echo "** this script requires newer AFNI binaries (than 27 Jun 2019)"
    echo "   (consider: @update.afni.binaries -defaults)"
    exit
endif

# the user may specify a single subject to run with
if ( $#argv > 0 ) then
    set subj = $argv[1]
else
    set subj = S001_20191218
endif

# assign output directory name
set output_dir = ./20191218_T2_S001_FN

# verify that the results directory does not yet exist
# if ( -d $output_dir ) then
#     echo output dir "$subj.results" already exists
#     exit
# endif

# set list of runs
set runs = (`count -digits 2 1 12`)  # 2表示显示2位数字，不足的用0补齐；1表示从1开始；12表示到12结束；结果为01 02 03 04 05 06 07 08 09 10 11 12 

# create results and stimuli directories
# mkdir $output_dir
mkdir $output_dir/stimuli

# ============================ auto block: tcat ============================
# apply 3dTcat to copy input dsets to results dir,
# while removing the first 0 TRs
3dTcat -prefix $output_dir/pb00.$subj.r01.tcat \
    20211009_T2_S000_EC/S000_20211009.r01.to3d+orig'[0..$]'  # '[0..$]'表示从第0个TR到最后一个TR（或者说sub-brick），这里的0可以根据需求来修改；在终端里可以键入：3dTcat -prefix test 20211009_T2_S000_EC/S000_20211009.r01.to3d+orig'[20..$]'，这样可以移除r01最初的20个TR

3dTcat -prefix $output_dir/pb00.$subj.r02.tcat \
    20211009_T2_S000_EC/S000_20211009.r02.to3d+orig'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r03.tcat \
    20211009_T2_S000_EC/S000_20211009.r03.to3d+orig'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r04.tcat \
    20211009_T2_S000_EC/S000_20211009.r04.to3d+orig'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r05.tcat \
    20211009_T2_S000_EC/S000_20211009.r05.to3d+orig'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r06.tcat \
    20211009_T2_S000_EC/S000_20211009.r06.to3d+orig'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r07.tcat \
    20211009_T2_S000_EC/S000_20211009.r07.to3d+orig'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r08.tcat \
    20211009_T2_S000_EC/S000_20211009.r08.to3d+orig'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r09.tcat \
    20211009_T2_S000_EC/S000_20211009.r09.to3d+orig'[0..$]'
3dTcat -prefix $output_dir/pb00.$subj.r10.tcat \
    20211009_T2_S000_EC/S000_20211009.r10.to3d+orig'[0..$]'

# and make note of repetitions (TRs) per run
set tr_counts = ( 294 294 294 294 294 294 294 294 316 330 )

# -------------------------------------------------------
# enter the results directory (can begin processing data)
cd $output_dir


```

---

`3dTcat`可以用来剪切，也可以用来连接，连接要用`.HEAD`文件，`.HEAD`可以用文本打开，而`.BRIK`是一个4D的数据

```bash
3dTcat -prefix test1 S000*r01*.HEAD S000*r05*.HEAD  # 由于本例中run01的数据类型是float，而run05的数据类型是short，所以连接这两个文件可能会报错，取决于afni的版本
```

大写的`T`表示这是一个用来对`时间`进行处理的命令

每个命令后面跟的option的位置可以改变，但是最后一个默认是`input`

---

时间校正里用到的一般都是交叉插值

```bash
# ================================= tshift =================================
# time shift data so all slice timing is the same 
foreach run ( $runs )
    3dTshift -tzero 0 -Fourier -prefix pb01.$subj.r$run.tshift \  # 插值方法默认用-Fourier，也可以用-quintic、-cubic，这里是 时间校正 的插值方式
             pb00.$subj.r$run.tcat+orig
end

# --------------------------------
# extract volreg registration base
3dbucket -prefix vr_base_min_outlier                           \
    pb01.$subj.r$minoutrun.tshift+orig"[$minouttr]"

```

---

```bash
# ================================= volreg =================================
# align each dset to base volume
foreach run ( $runs )
    # register each volume to the base image
    3dvolreg -verbose -zpad 1 -base vr_base_min_outlier+orig        \  # 基准选的是与平均相差最小那个;-zpad是将图像周围添加一点“画布”，防止对齐时被剪切
             -1Dfile dfile.r$run.1D -prefix pb02.$subj.r$run.volreg \
             -cubic                                                 \  # -cubic是一种插值方法，这里是 头动校正 的插值方式
             pb01.$subj.r$run.tshift+orig
end

# make a single file of registration params
cat dfile.r*.1D > dfile_rall.1D

# compute motion magnitude time series: the Euclidean norm
# (sqrt(sum squares)) of the motion parameter derivatives
1d_tool.py -infile dfile_rall.1D                                    \
           -set_run_lengths 294 294 294 294 294 294 294 294 316 330 \
           -derivative -collapse_cols euclidean_norm                \
           -write motion_${subj}_enorm.1D

```

---

```bash
# ================================ despike =================================
# apply 3dDespike to each run
foreach run ( $runs )
    3dDespike -NEW -nomask -localedit 3.5 -prefix pb03.$subj.r$run.despike \  # -NEW表示用了一种新的方法；-localedit表示把前后两个不是spike的值平均后填充回去（这里阈值设为3.5）
        pb02.$subj.r$run.volreg+orig
end

```

---

```bash
# ================================== blur ==================================
# blur each volume of each run
foreach run ( $runs )
    3dmerge -1blur_fwhm 3.5 -doall -prefix pb04.$subj.r$run.blur \
            pb03.$subj.r$run.despike+orig
end

```

---

```bash
# ================================= scale ==================================
# scale each voxel time series to have a mean of 100
# (be sure no negatives creep in)
# (subject to a range of [0,200])
foreach run ( $runs )
    3dTstat -prefix rm.mean_r$run pb04.$subj.r$run.blur+orig  # 3dTstat命令可以对时间进行统计，默认为取均值
    3dcalc -a pb04.$subj.r$run.blur+orig -b rm.mean_r$run+orig \
           -expr 'min(150, a/b*100)*step(a)*step(b)'           \
           -prefix pb05.$subj.r$run.scale
end

```

---

时间刺激文件里如果第一行只有一个值，需要补上空格和`*`，例如：`10 *`，告诉afni这行结束了

如果某一个run没有用到该刺激，则需要打上两个`*`，即：`**`

---

刺激文件单位是s，从0s开始计算

`3dbucket`和`3dTcat`很像，但这个主要是处理某一个sub_brick，而且可以更改label

```bash
3dinfo vr_base_min_outlier+orig.  # 然后可以看到打印base的基准信息
```

然后关注最后的history中曾经为了生成它而运行过的`3dbucket`文件


```bash
++ 3dinfo: AFNI version=AFNI_21.3.04 (Oct 20 2021) [64-bit]

Dataset File:    vr_base_min_outlier+orig
Identifier Code: AFN_24Yk-uTCnRqA8r6z3WadMQ  Creation Date: Fri Nov  5 15:03:23 2021
Template Space:  ORIG
Dataset Type:    Anat Bucket (-abuc)
Byte Order:      LSB_FIRST [this CPU native = LSB_FIRST]
Storage Mode:    BRIK
Storage Space:   762,048 (762 thousand) bytes
Geometry String: "MATRIX(2.5,0.003054,-0.000123,-106.4493,-0.002766,2.302962,0.972811,-126.4463,0.001302,-0.972809,2.302965,-21.69212):84,84,54"
Data Axes Tilt:  Oblique (22.900 deg. from plumb)
Data Axes Approximate Orientation:
  first  (x) = Right-to-Left
  second (y) = Anterior-to-Posterior
  third  (z) = Inferior-to-Superior   [-orient RAI]
R-to-L extent:  -106.449 [R] -to-   101.051 [L] -step-     2.500 mm [ 84 voxels]
A-to-P extent:  -126.446 [A] -to-    81.054 [P] -step-     2.500 mm [ 84 voxels]
I-to-S extent:   -21.692 [I] -to-   110.808 [S] -step-     2.500 mm [ 54 voxels]
Number of values stored at each pixel = 1
  -- At sub-brick #0 '#172' datum type is short:            0 to         26419

----- HISTORY -----
[rjx@rjx-virtual-machine: Fri Nov  5 14:56:05 2021] {AFNI_21.3.04:linux_ubuntu_16_64} 3dTcat -prefix ./20211009_T2_S000_EC/pb00.S000_20211009.r05.tcat '20211009_T2_S000_EC/S000_20211009.r05.to3d+orig[0..$]'
[rjx@rjx-virtual-machine: Fri Nov  5 15:01:48 2021] {AFNI_21.3.04:linux_ubuntu_16_64} 3dTshift -tzero 0 -Fourier -prefix pb01.S000_20211009.r05.tshift pb00.S000_20211009.r05.tcat+orig
[rjx@rjx-virtual-machine: Fri Nov  5 15:03:23 2021] {AFNI_21.3.04:linux_ubuntu_16_64} 3dbucket -prefix vr_base_min_outlier 'pb01.S000_20211009.r05.tshift+orig[172]'  # 关注这一行！！！
```

我们重新键入：

```bash
3dbucket -prefix S000_20211009.base 'pb01.S000_20211009.r05.tshift+orig[172]'  # 相当于给原来的vr_base_min_outlier换了个名字，称为S000_20211009.base，然后我们对它进行剥头皮 skull strip
```

剥头皮需要键入：

```bash
3dSkullStrip -prefix S000_20211009.base.ns -orig_vol -input S000_20211009.base+orig.  # ns表示no skull；-orig_vol表示生成一个brain，不仅仅只是01mask；这个命令必须要用到-input，不能像其他命令一样省略
```

然后我们把剥完头皮的大脑做成一个mask，在regress中会用到，这样大脑外的体素就不会纳入regress，可以大幅减少我们回归的时间，键入：

```bash
3dcalc -prefix S000_20211009.mask -a S000_20211009.base.ns+orig. -expr 'step(a)'
```

然后在老师给的regress的脚本里进行修改，将weight更改为mask，下面脚本中会有写

`@Process_BLOCK_ECircle`脚本是用来进行BLOCK的regress处理的，键入：

```bash
./@Process_BLOCK_ECircle S000_20211009 8 20211009_T2_S000_EC/
```

终端输出内容如下：

```bash
#!/bin/tcsh -xef

# =========================== auto block: setup ============================
# script setup

# take note of the AFNI version
afni -ver

# check that the current AFNI version is recent enough
afni_history -check_date 27 Jun 2019
if ( $status ) then
    echo "** this script requires newer AFNI binaries (than 27 Jun 2019)"
    echo "   (consider: @update.afni.binaries -defaults)"
    exit
endif

# the user may specify a single subject to run with
if ( $#argv < 3 ) then
    echo "@Process_BLOCK_ECircle subj(name_date) nRun folder"
    goto exit
else
    set subj = $argv[1]
    set nRun = $argv[2]
    set folder = $argv[3]
endif

cd ./$folder

3dAutobox -prefix rm.${subj}.box.1 -npad 3 -input ${subj}.weight+orig.  # 这里需要把weight更改为mask
3dcalc -prefix rm.${subj}.box.2 -a rm.${subj}.box.1+orig. -expr "step(a+1)"
3dresample -prefix ${subj}.box -master ${subj}.base+orig. -input rm.${subj}.box.2+orig.


# set list of runs
# set runs = (`count -digits 2 1 $nRun`)

# ================================= regress ================================

# make a single file of registration params
cat dfile.r01.1D 		\
    dfile.r02.1D 		\
    dfile.r03.1D 		\
    dfile.r04.1D 		\
    dfile.r05.1D 		\
    dfile.r06.1D 		\
    dfile.r07.1D 		\
    dfile.r08.1D 		\
    > dfile_rall.ECircle.1D  # rall表示all run

# compute de-meaned motion parameters (for use in regression)
1d_tool.py -infile dfile_rall.ECircle.1D -set_nruns ${nRun} -overwrite			\
           -demean -write motion_demean.ECircle.1D

# compute motion parameter derivatives (just to have)
1d_tool.py -infile dfile_rall.ECircle.1D -set_nruns ${nRun} -overwrite			\
           -derivative -demean -write motion_deriv.ECircle.1D


# ------------------------------
# run the regression analysis
3dDeconvolve -input pb05.${subj}.r01.scale+orig.HEAD					\
                    pb05.${subj}.r02.scale+orig.HEAD					\
                    pb05.${subj}.r03.scale+orig.HEAD					\
                    pb05.${subj}.r04.scale+orig.HEAD					\
                    pb05.${subj}.r05.scale+orig.HEAD					\
                    pb05.${subj}.r06.scale+orig.HEAD					\
                    pb05.${subj}.r07.scale+orig.HEAD					\
                    pb05.${subj}.r08.scale+orig.HEAD					\
    -polort A										\
    -jobs 8										\  # 表示分成了8个任务去处理，可以让程序跑的更快
    -mask ${subj}.box+orig.								\
    -num_stimts 10									\  # 刺激文件明明只有4个，为什么这里写的10呢，下面有讲到
    -num_glt 4										\
    -stim_times 1 ./stimuli/${subj}.rall.homo_same.1D 'BLOCK(15,1)'			\
    -stim_label 1 homo_same								\
    -stim_times 2 ./stimuli/${subj}.rall.homo_diff.1D 'BLOCK(15,1)'			\
    -stim_label 2 homo_diff								\
    -stim_times 3 ./stimuli/${subj}.rall.nocue_same.1D 'BLOCK(15,1)'			\
    -stim_label 3 nocue_same								\
    -stim_times 4 ./stimuli/${subj}.rall.nocue_diff.1D 'BLOCK(15,1)'			\
    -stim_label 4 nocue_diff								\
    -stim_file 5  motion_demean.ECircle.1D'[0]'  -stim_base 5  -stim_label 5  roll	\  # -stim_base其实是不好的东西，即 头动
    -stim_file 6  motion_demean.ECircle.1D'[1]'  -stim_base 6  -stim_label 6  pitch	\
    -stim_file 7  motion_demean.ECircle.1D'[2]'  -stim_base 7  -stim_label 7  yaw	\
    -stim_file 8  motion_demean.ECircle.1D'[3]'  -stim_base 8  -stim_label 8  dS 	\
    -stim_file 9  motion_demean.ECircle.1D'[4]'  -stim_base 9  -stim_label 9  dL 	\
    -stim_file 10 motion_demean.ECircle.1D'[5]'  -stim_base 10 -stim_label 10 dP 	\  # 4个刺激文件，外加6个头动参数，所以上面填的10；如果不加头动参数，最终结果可能相差10%
    -gltsym 'SYM: +homo_same -homo_diff'						\
    -glt_label 1 homo_same_vs_diff							\
    -gltsym 'SYM: +nocue_same -nocue_diff'						\
    -glt_label 2 nocue_same_vs_diff							\
    -gltsym 'SYM: +homo_same -nocue_same'						\
    -glt_label 3 same_homo_vs_nocue							\
    -gltsym 'SYM: +homo_diff -nocue_diff'						\
    -glt_label 4 diff_homo_vs_nocue							\
    -fout -tout -x1D X.xmat.${subj}.BLOCK.ECircle.1D					\
    #-x1D_stop										\
    #-fitts fitts.${subj}.BLOCK.ECircle							\
    -errts errts.${subj}.BLOCK.ECircle							\  # errts是残差文件，一般数据很大，最后可以删掉，但PPI时可能要用，所以还是别删了
    #-cbucket cbucket.${subj}.BLOCK.ECircle						\
    -bucket stats.${subj}.BLOCK.ECircle  # 创建一个AFNI“bucket”数据集，其中包含各种感兴趣的参数，也就是我们生成的stat文件
    

# if 3dDeconvolve fails, terminate the script
if ( $status != 0 ) then
    echo '---------------------------------------'
    echo '** 3dDeconvolve error, failing...'
    echo '   (consider the file 3dDeconvolve.err)'
    exit
endif


# display any large pairwise correlations from the X-matrix
1d_tool.py -show_cormat_warnings -infile X.xmat.${subj}.BLOCK.ECircle.1D |& tee out.cormat_warn.txt

# display degrees of freedom info from X-matrix
1d_tool.py -show_df_info -infile X.xmat.${subj}.BLOCK.ECircle.1D |& tee out.df_info.txt

# create an all_runs dataset to match the fitts, errts, etc.
3dTcat -prefix all.ECircle_runs.${subj}					\
       pb05.${subj}.r01.scale+orig.HEAD 				\
       pb05.${subj}.r02.scale+orig.HEAD 				\
       pb05.${subj}.r03.scale+orig.HEAD 				\
       pb05.${subj}.r04.scale+orig.HEAD 				\
       pb05.${subj}.r05.scale+orig.HEAD 				\
       pb05.${subj}.r06.scale+orig.HEAD 				\
       pb05.${subj}.r07.scale+orig.HEAD 				\
       pb05.${subj}.r08.scale+orig.HEAD

# --------------------------------------------------
# create a temporal signal to noise ratio dataset 
#    signal: if 'scale' block, mean should be 100
#    noise : compute standard deviation of errts
3dTstat -mean -prefix rm.signal.all all.ECircle_runs.${subj}+orig
3dTstat -stdev -prefix rm.noise.all errts.${subj}.BLOCK.ECircle+orig
3dcalc -a rm.signal.all+orig                                      	\
       -b rm.noise.all+orig                                       	\
       -expr 'a/b' -prefix TSNR.ECircle.${subj}  # TSNR表示时间的信噪比


rm rm.*
rm errts*

echo "execution finished: `date`"


exit:
```

上面脚本跑完之后，预处理完成，可以打开afni看看结果

underlay选择`S000_20211009.base`；overlay选择`stat.S000_20211009.BLOCK.ECircle`；即底层选的是配准对齐的那张slice，表层是分析用的stat文件

Ulay和Olay均选择`Full_Fstat`，结果如下图：

![image.png](https://i.loli.net/2021/11/05/OedGAKphMICVZJD.png)

在Ulay和Olay均选择`Full_Fstat`的情况下，Thr（threshold）的范围越大，往往说明预处理的结果越好

Olay决定了你看到的是什么，如果你Olay设的是`homo_same#0_Coef`，那图上彩色的部分一定是和`homo_same`条件有关的脑区

Thr决定有哪些体素能被你看到，或者说决定你能看到多少体素，一般Thr用的都是`*_Tstat`，因为t检验表明了你这个体素激活的可信度，这样卡阈值有激活还是没有激活、正激活还是负激活才有意义

p值和t值是绑定的，即只要t值变化，p值就会变化，在文献中我们常常设置p值，afni里当然也可以设置p值，但是左边的bar设置的是t值，p值需要右键长按下边的`p`才能设

---

接下来跑`@Process_TENT_ECircle`脚本，这个脚本用的不同于BLOCK的处理方式，BLOCK相当于直接告诉afni曲线大概的样子，但是TENT（直译为帐篷）是一个一个的拟合，键入：

```bash
./@Process_TENT_ECircle S000_20211009 8 20211009_T2_S000_EC/
```

终端显示的内容如下：

```bash
#!/bin/tcsh -xef

# =========================== auto block: setup ============================
# script setup

# take note of the AFNI version
afni -ver

# check that the current AFNI version is recent enough
afni_history -check_date 27 Jun 2019
if ( $status ) then
    echo "** this script requires newer AFNI binaries (than 27 Jun 2019)"
    echo "   (consider: @update.afni.binaries -defaults)"
    exit
endif

# the user may specify a single subject to run with
if ( $#argv < 3 ) then
    echo "@Process_TENT_ECircle subj(name_date) nRun folder"
    goto exit
else
    set subj = $argv[1]
    set nRun = $argv[2]
    set folder = $argv[3]
endif

cd ./$folder

# ------------------------------
# run the regression analysis
3dDeconvolve -input pb05.${subj}.r01.scale+orig.HEAD					\
                    pb05.${subj}.r02.scale+orig.HEAD					\
                    pb05.${subj}.r03.scale+orig.HEAD					\
                    pb05.${subj}.r04.scale+orig.HEAD					\
                    pb05.${subj}.r05.scale+orig.HEAD					\
                    pb05.${subj}.r06.scale+orig.HEAD					\
                    pb05.${subj}.r07.scale+orig.HEAD					\
                    pb05.${subj}.r08.scale+orig.HEAD					\
    -polort A										\
    -jobs 8										\
    -mask ${subj}.box+orig.								\
    -num_stimts 10									\
    -num_glt 4										\
    -stim_times 1 ./stimuli/${subj}.rall.homo_same.1D 'TENT(0,21.25,18)'		\  # 0表示从0s开始算，18表示有18个TR，中间为：(18-1)×1.25=21.25；其中TR=1.25；为什么是这么计算的呢？假设当第0s开始时第1个刺激呈现，同时第1个TR开始扫描，第22.5s时，（时间刺激文件规定）第2个刺激呈现，这时也是第18个TR开始扫描，所以前面17个TR代表的是第1个刺激下扫描的(block+blank)，而TENT就是一个TR时间一个TR时间的去拟合时间曲线
    -stim_label 1 homo_same								\
    -stim_times 2 ./stimuli/${subj}.rall.homo_diff.1D 'TENT(0,21.25,18)'		\
    -stim_label 2 homo_diff								\
    -stim_times 3 ./stimuli/${subj}.rall.nocue_same.1D 'TENT(0,21.25,18)'		\
    -stim_label 3 nocue_same								\
    -stim_times 4 ./stimuli/${subj}.rall.nocue_diff.1D 'TENT(0,21.25,18)'		\
    -stim_label 4 nocue_diff								\
    -stim_file 5  motion_demean.ECircle.1D'[0]'  -stim_base 5  -stim_label 5  roll	\
    -stim_file 6  motion_demean.ECircle.1D'[1]'  -stim_base 6  -stim_label 6  pitch	\
    -stim_file 7  motion_demean.ECircle.1D'[2]'  -stim_base 7  -stim_label 7  yaw	\
    -stim_file 8  motion_demean.ECircle.1D'[3]'  -stim_base 8  -stim_label 8  dS 	\
    -stim_file 9  motion_demean.ECircle.1D'[4]'  -stim_base 9  -stim_label 9  dL 	\
    -stim_file 10 motion_demean.ECircle.1D'[5]'  -stim_base 10 -stim_label 10 dP 	\
#    -gltsym 'SYM: +homo_same -homo_diff'						\
#    -glt_label 1 homo_same_vs_diff							\
#    -gltsym 'SYM: +nocue_same -nocue_diff'						\
#    -glt_label 2 nocue_same_vs_diff							\
#    -gltsym 'SYM: +homo_same -nocue_same'						\
#    -glt_label 3 same_homo_vs_nocue							\
#    -gltsym 'SYM: +homo_diff -nocue_diff'						\
#    -glt_label 4 diff_homo_vs_nocue							\
    -iresp 1 ./TS_homo_same.TENT							\  # i response，会给出每个条件下的拟合曲线，后面的代码还会把他们整合在一起，并且下面的图像中会进行查看
    -iresp 2 ./TS_homo_diff.TENT							\
    -iresp 3 ./TS_nocue_same.TENT							\
    -iresp 4 ./TS_nocue_diff.TENT							\
    -fout -tout -x1D X.xmat.${subj}.TENT.ECircle.1D					\
    #-x1D_stop										\
    #-fitts fitts.${subj}.TENT.ECircle							\
    #-errts errts.${subj}.TENT.ECircle							\
    #-cbucket cbucket.${subj}.TENT.ECircle						\
    -bucket stats.${subj}.TENT.ECircle
    


# if 3dDeconvolve fails, terminate the script
if ( $status != 0 ) then
    echo '---------------------------------------'
    echo '** 3dDeconvolve error, failing...'
    echo '   (consider the file 3dDeconvolve.err)'
    exit
endif


3dTcat -prefix TS.TENT.ECircle TS_homo_same.TENT+orig. TS_homo_diff.TENT+orig. TS_nocue_same .TENT+orig. TS_nocue_diff.TENT+orig.  # 这里把每个前面每个条件下拟合的曲线整合在一起，下面在图像中可以查看，在这里也可以确定条件间的顺序，即homo_same homo_diff nocue_same nocue_diff


echo "execution finished: `date`"

exit:

```

打开afni，underlay选择`TS.TENT.ECircle`，overlay依旧可以选择`stat.S000_20211009.BLOCK.ECircle`，卡一个好一点的Thr，如下图

`Graph`里的`Opt`里面可以调整`Grid`，将其默认值设置为TR数量，即设为18

![image.png](https://i.loli.net/2021/11/05/OMGEHBFC8VqdYjP.png)

当你在afni的UI界面中同时打开多个窗口，在任意`Image`中选择体素会改变所有窗口的选择，可以在`Define Datamode`中的`Lock`选择`Clear All`，这样就可以接触各个窗口之间的锁定，选择`Set All`可以再修改回来

---

最后可以将被试的原大脑结构像配准到功能像上，这样生成的`stat`文件就可以直接overlay在原结构像上面，更好地帮助我们判断脑区，键入：

```bash
3dWarp -prefix S000_20211009.T1.toEPI -oblique_parent S000_20211009.base+orig. S000_20211009.T1.to3d+orig.  # 虽然被试躺在里面头并不能动，但是可以移动“取景框”，来将原结构像配准到功能像；但是注意如果被试头动过大也是配准不了的；-oblique_parent后面跟的就是用于配准的那个基准slice，最后跟的是原始结构像，这里不用加-input,同时复习一下3dSkullStrip命令中的输入项需要加-input
```

打开afni，underlay选择`S000_20211009.T1.toEPI`，overlay依旧可以选择`stat.S000_20211009.BLOCK.ECircle`，卡一个好一点的Thr，如下图

![image.png](https://i.loli.net/2021/11/06/cqL8FvUMswXSzgm.png)

---

同一次扫描中如果有2种任务，一起跑会影响每个任务中的分析

例如run01-12和loc_run01-02，合在一起可能会造成自由度的变换，最终造成T值、F值的变化，影响分析结果

具体可以看`@Process_BLOCK_FN`脚本里`-polort A`这条命令的作用；这个命令把数据当中一些线性漂移，还有一些2阶或者3阶漂移去掉

可以打开`X.xmat.S001_20191218.BLOCK.ECircle.1D`文件看前面一部分：

```bash
# <matrix
#  ni_type = "90*double"
#  ni_dimen = "4252"
#  ColumnLabels = "Run#1Pol#0 ; Run#1Pol#1 ; Run#1Pol#2 ; Run#1Pol#3 ; Run#2Pol#0 ; Run#2Pol#1 ; Run#2Pol#2 ; Run#2Pol#3 ; Run#3Pol#0 ; Run#3Pol#1 ; Run#3Pol#2 ; Run#3Pol#3 ; Run#4Pol#0 ; Run#4Pol#1 ; Run#4Pol#2 ; Run#4Pol#3 ; Run#5Pol#0 ; Run#5Pol#1 ; Run#5Pol#2 ; Run#5Pol#3 ; Run#6Pol#0 ; Run#6Pol#1 ; Run#6Pol#2 ; Run#6Pol#3 ; Run#7Pol#0 ; Run#7Pol#1 ; Run#7Pol#2 ; Run#7Pol#3 ; Run#8Pol#0 ; Run#8Pol#1 ; Run#8Pol#2 ; Run#8Pol#3 ; Run#9Pol#0 ; Run#9Pol#1 ; Run#9Pol#2 ; Run#9Pol#3 ; Run#10Pol#0 ; Run#10Pol#1 ; Run#10Pol#2 ; Run#10Pol#3 ; Run#11Pol#0 ; Run#11Pol#1 ; Run#11Pol#2 ; Run#11Pol#3 ; Run#12Pol#0 ; Run#12Pol#1 ; Run#12Pol#2 ; Run#12Pol#3 ; Run#13Pol#0 ; Run#13Pol#1 ; Run#13Pol#2 ; Run#13Pol#3 ; Run#14Pol#0 ; Run#14Pol#1 ; Run#14Pol#2 ; Run#14Pol#3 ; Diff_F_Level20#0 ; Diff_F_Level40#0 ; Diff_F_Level60#0 ; Diff_F_Level80#0 ; Diff_M_Level20#0 ; Diff_M_Level40#0 ; Diff_M_Level60#0 ; Diff_M_Level80#0 ; Mix_F_Level20#0 ; Mix_F_Level40#0 ; Mix_F_Level60#0 ; Mix_F_Level80#0 ; Mix_M_Level20#0 ; Mix_M_Level40#0 ; Mix_M_Level60#0 ; Mix_M_Level80#0 ; Same_F_Level20#0 ; Same_F_Level40#0 ; Same_F_Level60#0 ; Same_F_Level80#0 ; Same_M_Level20#0 ; Same_M_Level40#0 ; Same_M_Level60#0 ; Same_M_Level80#0 ; Car#0 ; Face#0 ; Place#0 ; Scramble#0 ; roll#0 ; pitch#0 ; yaw#0 ; dS#0 ; dL#0 ; dP#0"
```

里面类似`Run#1Pol#0`的分别是每个run去漂移的参数，run的数量越多，polort的参数可能越多

上面的如果前面12个run和后面2个定位用的run合在一起就可能改变这里的polort参数的数量（有可能从2个polort参数增加到3个polort参数），从而影响自由度，接下来影响一系列的数据分析结果

反正记住不是同一种任务的结果不要放到一起去分析，因为会改变回归时候的一些参数

---

如果event设计中的刺激与刺激间的时间间隔不等，可以取平均，例如最短为4s，最长为12s，平均取10s（有一点偏差也没有关系）

---

fMRI中的线圈可能对额叶是不友好的，造成功能像中眶额叶部分的缺失

是可以对这种情况进行修正的，例如`20211009_T2_S000_EC`文件夹下有个名为`S001_20211009.rPA.to3d`的文件

![image.png](https://i.loli.net/2021/11/08/SdVgN2Lp3zFAMrk.png)

正常是AP方向采集，现在换成了PA方向采集，能够把缺陷的眶额叶修补回来，但是会导致颞叶的部分受损；而且这一方向不会采很多，这里只采取了10个

---

tlrc和MNI标准模板之间拥有换算公式，atlas是大脑脑区的分布图，使用不同的模板对齐，坐标可能不同，不同的atlas对同一脑区的命名可能会不一样

在afni里面，配准到标准模板之后的数据全部都会命名为+tlrc，无论到底配准到的是tlrc还是MNI

---

在配准到标准脑之前，需要将原来的`toEPI`像剥掉头皮，键入：

```bash
3dSkullStrip -prefix S001_20191218.T1.toEPI.ns -orig_vol -input S001_20191218.T1.toEPI+orig
```

然后键入：

```bash
auto_warp.py -base /home/rjx/abin/TT_N27+tlrc \
	-qworkhard 0 2 \
	-skull_strip_input no \
	-input S001_20191218.T1.toEPI.ns+orig  # -qworkhard表示这个命令会多努力地去执行这个命令，要明确这个值不是越大越好；-skull_strip_input表示你输入的文件是否需要剥头皮，如果已经剥过头皮了就不需要再剥了，所以选no
```

上面一行命令会自动在输入项所在文件夹里生成一个`awpy`文件夹，并把最终配准的文件以及配准用到的矩阵放在文件夹中，如果文件夹生成错误，也可以添加以下option：

```bash
auto_warp.py -base /home/rjx/abin/TT_N27+tlrc \
	-qworkhard 0 2 \
	-output_dir ./awpy \
	-skull_strip_input no \
	-input S001_20191218.T1.toEPI.ns+orig  # 这里添加了-output_dir选项，并且可以自定义想要存结果的文件夹
```

完成之后可以打开afni看看配准完的图像和标准模板之间的差异，只要大沟配准的好就可以了（侧裂，颞上/下沟，额上/下沟）

aw表示auto warp

---

以上已经完成了将**与功能像配准的结构像**配准到标准模板上，而且生成了一个配准方式（是一个3D数据集加上一个1D文件），都存在`awpy`文件夹中

这种配准用到的变换是非线性变换（是一个很复杂的矩阵，但是不同于线性变换的矩阵），但首先会先进行一个线性变换大致对齐，然后再进行非线性变换完全对齐

接下来，只需要将相同的配准方式应用到各个功能像上就可以了，这里只介绍`S001_20191218.base`文件的例子，键入：

```bash
3dNwarpApply -nwarp "anat.un.aff.qw_WARP.nii anat.un.aff.Xat.1D" \
	-master ./S001_20191218.T1.toEPI.ns.aw.nii \
	-dxyz 3 \
	-source ../S001_20191218.base+orig \
	-prefix ./S001_20191218.base.aw.nii  # -nwarp后面跟的就是前面计算出来的配准方式（一个3D数据集加上一个1D文件）；-master表示你要配准到哪个文件上面去；-dxyz表示大小，即3×3×3；-source和-input类似，指你想要配准的文件
```

同样可以对`stats.S000_20211009.BLOCK.ECircle+orig`进行配准

---

ttest可以做的，ANOVA也可以做；ANOVA能做的，ttest不一定能做

ttest可以包含协变量

因为ttest是voxel by voxel地进行比较，所以需要输入对齐到标准脑上的文件

一般用β值来做ttest，不是说t值不能做；按道理来说，β值可能本身就很大，ttest之后显著，但是这种显著可能没意义；而t值经过ttest之后的显著肯定就是显著，但是t值一般不能直接用来ttest，因为它不是正态分布，需要进行z转换

---

自己写个脚本`@pair_ttest_FN`来做ttest，内容如下：

```bash
#!/bin/bash

3dttest++ -prefix ttest_Face_vs_Scramble -paired							\  # -prefix后面可以指定到想要放置的文件夹里
    -setA																	\
    ./20191218_T2_S001_FN/awpy/stats.S001_20191218.BLOCK.loc.aw.nii'[4]'	\  # .nii文件一定要加.nii
    ./20191218_T2_S002_FN/awpy/stats.S002_20191218.BLOCK.loc.aw.nii'[4]'	\
    ./20191220_T2_S003_FN/awpy/stats.S003_20191220.BLOCK.loc.aw.nii'[4]'	\
    ./20191220_T2_S004_FN/awpy/stats.S004_20191220.BLOCK.loc.aw.nii'[4]'	\
    ./20200420_T2_S005_FN/awpy/stats.S005_20200420.BLOCK.loc.aw.nii'[4]'	\
    ./20200420_T2_S006_FN/awpy/stats.S006_20200420.BLOCK.loc.aw.nii'[4]'	\
    ./20200420_T2_S007_FN/awpy/stats.S007_20200420.BLOCK.loc.aw.nii'[4]'	\
    -setB																	\
    ./20191218_T2_S001_FN/awpy/stats.S001_20191218.BLOCK.loc.aw.nii'[10]'	\
    ./20191218_T2_S002_FN/awpy/stats.S002_20191218.BLOCK.loc.aw.nii'[10]'	\
    ./20191220_T2_S003_FN/awpy/stats.S003_20191220.BLOCK.loc.aw.nii'[10]'	\
    ./20191220_T2_S004_FN/awpy/stats.S004_20191220.BLOCK.loc.aw.nii'[10]'	\
    ./20200420_T2_S005_FN/awpy/stats.S005_20200420.BLOCK.loc.aw.nii'[10]'	\
    ./20200420_T2_S006_FN/awpy/stats.S006_20200420.BLOCK.loc.aw.nii'[10]'	\
    ./20200420_T2_S007_FN/awpy/stats.S007_20200420.BLOCK.loc.aw.nii'[10]'
```

---

`3dANOVA`可以用来分析 one-way between subj（总体用的比较少）

```bash
#!/bin/bash

3dANOVA -levels 2																	\
    -dset 1 ./20191218_T2_S001_FN/awpy/stats.S001_20191218.BLOCK.loc.aw.nii'[4]'	\
    -dset 1 ./20191218_T2_S002_FN/awpy/stats.S002_20191218.BLOCK.loc.aw.nii'[4]'	\
    -dset 1 ./20191220_T2_S003_FN/awpy/stats.S003_20191220.BLOCK.loc.aw.nii'[4]'	\
    -dset 1 ./20191220_T2_S004_FN/awpy/stats.S004_20191220.BLOCK.loc.aw.nii'[4]'	\
    -dset 1 ./20200420_T2_S005_FN/awpy/stats.S005_20200420.BLOCK.loc.aw.nii'[4]'	\
    -dset 1 ./20200420_T2_S006_FN/awpy/stats.S006_20200420.BLOCK.loc.aw.nii'[4]'	\
    -dset 1 ./20200420_T2_S007_FN/awpy/stats.S007_20200420.BLOCK.loc.aw.nii'[4]'	\
    -dset 2 ./20191218_T2_S001_FN/awpy/stats.S001_20191218.BLOCK.loc.aw.nii'[10]'	\
    -dset 2 ./20191218_T2_S002_FN/awpy/stats.S002_20191218.BLOCK.loc.aw.nii'[10]'	\
    -dset 2 ./20191220_T2_S003_FN/awpy/stats.S003_20191220.BLOCK.loc.aw.nii'[10]'	\
    -dset 2 ./20191220_T2_S004_FN/awpy/stats.S004_20191220.BLOCK.loc.aw.nii'[10]'	\
    -dset 2 ./20200420_T2_S005_FN/awpy/stats.S005_20200420.BLOCK.loc.aw.nii'[10]'	\
    -dset 2 ./20200420_T2_S006_FN/awpy/stats.S006_20200420.BLOCK.loc.aw.nii'[10]'	\
    -dset 2 ./20200420_T2_S007_FN/awpy/stats.S007_20200420.BLOCK.loc.aw.nii'[10]'	\
    -mean 1 Face																	\
    -mean 2 Scramble																\
    -diff 1 2 Face_vs_Scramble														\
    -bucket ANOVA_Face_Scramble
```



`3dANOVA2`可以用来分析 one-way within subj，2-way between subj

```bash
#!/bin/bash

3dANOVA2 -type 3 -alevel 2 -blevel 7												\
    -dset 1 1 ./20191218_T2_S001_FN/awpy/stats.S001_20191218.BLOCK.loc.aw.nii'[4]'	\
    -dset 1 2 ./20191218_T2_S002_FN/awpy/stats.S002_20191218.BLOCK.loc.aw.nii'[4]'	\
    -dset 1 3 ./20191220_T2_S003_FN/awpy/stats.S003_20191220.BLOCK.loc.aw.nii'[4]'	\
    -dset 1 4 ./20191220_T2_S004_FN/awpy/stats.S004_20191220.BLOCK.loc.aw.nii'[4]'	\
    -dset 1 5 ./20200420_T2_S005_FN/awpy/stats.S005_20200420.BLOCK.loc.aw.nii'[4]'	\
    -dset 1 6 ./20200420_T2_S006_FN/awpy/stats.S006_20200420.BLOCK.loc.aw.nii'[4]'	\
    -dset 1 7 ./20200420_T2_S007_FN/awpy/stats.S007_20200420.BLOCK.loc.aw.nii'[4]'	\
    -dset 2 1 ./20191218_T2_S001_FN/awpy/stats.S001_20191218.BLOCK.loc.aw.nii'[10]'	\
    -dset 2 2 ./20191218_T2_S002_FN/awpy/stats.S002_20191218.BLOCK.loc.aw.nii'[10]'	\
    -dset 2 3 ./20191220_T2_S003_FN/awpy/stats.S003_20191220.BLOCK.loc.aw.nii'[10]'	\
    -dset 2 4 ./20191220_T2_S004_FN/awpy/stats.S004_20191220.BLOCK.loc.aw.nii'[10]'	\
    -dset 2 5 ./20200420_T2_S005_FN/awpy/stats.S005_20200420.BLOCK.loc.aw.nii'[10]'	\
    -dset 2 6 ./20200420_T2_S006_FN/awpy/stats.S006_20200420.BLOCK.loc.aw.nii'[10]'	\
    -dset 2 7 ./20200420_T2_S007_FN/awpy/stats.S007_20200420.BLOCK.loc.aw.nii'[10]'	\
    -amean 1 Face																	\
    -amean 2 Scramble																\
    -adiff 1 2 Face_vs_Scramble														\
    -bucket ANOVA2_Face_vs_Scramble
```



`3dANOVA3`可以用来分析 2-way within-subj & mixed，3-way between-subj

一个因素在被试内，一个因素在被试间就是混合设计

>  fixed：指因素的水平明确
>
> random：指因素的水平不清晰，有其他没有穷举的水平；不想研究的东西，应该都属于random，我们就需要从这些因素里去随机抽样，把这些因素随机掉

3dANOVA3里的`-type`也和因素是`within`还是`between`有关，需要范例里面去看

